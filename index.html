<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Original Torrent</title>

  <!-- Farcaster discovery -->
  <meta name="fc:miniapp" content='{"version":"1","image":"https://play.originaltorrent.com/icon.png","actions":[{"label":"Open","action":"launch_miniapp","url":"https://play.originaltorrent.com"}]}' />
  <style>
    :root { --gap:12px; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; background: #fff; color: #000; }
    h1 { margin: 0 0 8px; }
    .card { border:1px solid #e5e5e5; border-radius:12px; padding:16px; margin-bottom:16px; }
    .row { display:grid; gap: var(--gap); grid-template-columns: 1fr auto; align-items:center; }
    input[type="text"] { width:100%; padding:10px; border:1px solid #ddd; border-radius:10px; }
    input[type="file"] { border:1px dashed #bbb; padding:10px; border-radius:10px; }
    button { padding:10px 14px; border:1px solid #ddd; border-radius:10px; background:#f8f8f8; cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    audio { width:100%; margin-top:10px; }
    .meta { font-size:12px; color:#555; margin-top:6px; }
    #log { font-family: ui-monospace, Menlo, Consolas, monospace; font-size:12px; background:#0b0b0b; color:#d4d4d4; padding:10px; border-radius:10px; max-height:180px; overflow:auto; }
    .flex { display:flex; gap:var(--gap); flex-wrap:wrap; align-items:center; }
    .pill { font-size:12px; padding:4px 8px; border-radius:999px; background:#f2f2f2; border:1px solid #e5e5e5; }
    .small { font-size:12px; }
  </style>
</head>
<body>
  <h1>Original Torrent</h1>

  <!-- Listener -->
  <div class="card">
    <h2 style="margin-top:0">Listen</h2>
    <div class="row">
      <input id="magnet" type="text" placeholder="Paste magnet URI (licensed content only)" />
      <button id="playBtn">Play</button>
    </div>
    <div class="meta">
      <span id="status">Idle.</span>
      <span id="stats"></span>
    </div>
    <audio id="player" controls preload="none" playsinline></audio>
  </div>

  <div class="card">
    <h3>Create & Seed</h3>
    <input id="fileInput" type="file" accept="audio/*" />
    <button id="seedBtn">Seed</button>
    <div id="seedStatus" style="margin-top:8px;font:12px system-ui">Idle.</div>
    <div id="magnetRow" style="display:none;margin-top:8px">
      <input id="magnetOut" type="text" readonly style="width:100%;padding:8px;border:1px solid #ddd;border-radius:8px" />
      <button id="copyBtn" style="margin-top:8px;padding:8px 12px;border:1px solid #ddd;border-radius:8px;background:#f7f7f7">Copy magnet</button>
    </div>
  </div>

  <div class="card">
    <div class="flex">
      <div class="pill" id="peerCount">Peers: 0</div>
      <div class="pill" id="speed">0 KB/s</div>
      <div class="pill" id="progress">0%</div>
    </div>
  </div>

  <div id="log" class="card"></div>

  <!-- Farcaster MiniApp SDK -->
  <script type="module">
    import { sdk } from "https://esm.sh/@farcaster/miniapp-sdk";
    addEventListener("DOMContentLoaded", () => {
      try { sdk.actions.ready(); } catch {}
    });
  </script>

  <!-- WebTorrent (browser ESM) + app logic -->
  <script type="module">
    import WebTorrent from "https://esm.sh/webtorrent@2.3.0";

    // UI
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const statsEl  = document.getElementById('stats');
    const peerEl   = document.getElementById('peerCount');
    const speedEl  = document.getElementById('speed');
    const progEl   = document.getElementById('progress');
    const magnetEl = document.getElementById('magnet');
    const playBtn  = document.getElementById('playBtn');
    const player   = document.getElementById('player');
    const fileInput  = document.getElementById('fileInput');
    const seedBtn    = document.getElementById('seedBtn');
    const seedStatus = document.getElementById('seedStatus');
    const magnetRow  = document.getElementById('magnetRow');
    const magnetOut  = document.getElementById('magnetOut');
    const copyBtn    = document.getElementById('copyBtn');

    let cfg, client, activeTorrent;

    const log = (m) => { logEl.textContent += m + "\\n"; logEl.scrollTop = logEl.scrollHeight; };
    window.log = log;
    function setStatus(msg) {
      seedStatus.textContent = msg;
    }
    const human = (n) => {
      if (n === 0) return "0 B";
      const u = ["B","KB","MB","GB","TB"]; let i=0; while(n>=1024 && i<u.length-1){n/=1024;i++;} return n.toFixed(1)+" "+u[i];
    };

    async function loadConfig() {
      if (cfg) return cfg;
      try {
        const res = await fetch("./config.json", { cache: "no-store" });
        if (!res.ok) {
          throw new Error(res.statusText || ("HTTP " + res.status));
        }
        cfg = await res.json();
      } catch (e) {
        const msg = "Failed to load config.";
        statusEl.textContent = msg;
        setStatus(msg);
        log(msg + " " + (e?.message || e));
        throw e;
      }
      return cfg;
    }

    async function ensureClient() {
      if (client) return client;
      const conf = await loadConfig();
      client = new WebTorrent({
        tracker: { rtcConfig: { iceServers: conf.iceServers || [] } }
      });
      client.on("error", (e) => {
        const msg = "Client error: " + (e?.message || e);
        log(msg);
        setStatus(msg);
      });
      client.on("warning", (e) => log("Client warning: " + (e?.message || e)));
      return client;
    }

    function chooseAudioFile(files) {
      const candidates = files.filter(f => /\.(mp3|m4a|aac|wav|ogg|opus|flac)$/i.test(f.name));
      return candidates[0] || files[0];
    }

    function hookTorrentEvents(torrent) {
      torrent.on('warning', e => log("⚠️ " + e.message));
      torrent.on('error',   e => log("❌ " + (e?.message || e)));
      torrent.on('trackerAnnounce', t => log("Tracker announce: " + (t?.announce || t)));
      torrent.on('trackerWarning', e => log("Tracker warning: " + (e?.message || e)));
      torrent.on('trackerError',   e => log("Tracker error: " + (e?.message || e)));
      torrent.on('noPeers', type => log("No peers: " + type));

      const updateStats = () => {
        peerEl.textContent = "Peers: " + torrent.numPeers;
        speedEl.textContent = human(torrent.downloadSpeed) + "/s";
        progEl.textContent = (torrent.progress * 100).toFixed(1) + "%";
        statsEl.textContent = ` | ${human(torrent.downloaded)} of ${human(torrent.length)}`;
      };
      setInterval(() => { if (torrent) updateStats(); }, 1000);

      torrent.on('wire', updateStats);
      torrent.on('download', updateStats);
      torrent.on('done', () => { updateStats(); statusEl.textContent = "Complete."; log("Download complete."); });
    }

    async function playMagnet(c, magnetURI) {
      const conf = await loadConfig();

      // Clean up previous torrent if present
      if (activeTorrent) {
        try { activeTorrent.destroy({ destroyStore: false }); } catch {}
        activeTorrent = null;
      }

      statusEl.textContent = "Connecting…";
      log("Adding torrent: " + magnetURI);
      let announce = conf.trackers || [];
      try {
        const url = new URL(magnetURI);
        const tr = url.searchParams.getAll('tr');
        announce = Array.from(new Set([...announce, ...tr]));
      } catch {}

      const torrent = c.add(magnetURI, { announce });
      activeTorrent = torrent;
      hookTorrentEvents(torrent);

      torrent.on('metadata', () => {
        log("Metadata: " + torrent.name);
        const file = chooseAudioFile(torrent.files);
        if (!file) { statusEl.textContent = "No audio file found in torrent."; return; }

        // Preload initial bytes to reduce start-up stutter
        try {
          const pre = Math.ceil((conf.prerollBytes || 2_000_000) / torrent.pieceLength);
          torrent.select(0, Math.max(0, pre - 1), true);
        } catch {}

        // Stream directly to <audio> element
        file.renderTo(player, { autoplay: false }, (err) => {
          if (err) { statusEl.textContent = "Render failed."; log("Render error: " + err.message); return; }
          statusEl.textContent = "Buffering…";
          const maybePlay = () => {
            if (player.readyState >= 2) {
              player.play().catch(()=>{});
              statusEl.textContent = "Playing.";
            }
          };
          player.addEventListener('canplay', maybePlay, { once: true });
          setTimeout(maybePlay, 800);
        });
      });
    }
    
    async function seedLocalFile(c, file) {
      seedBtn.disabled = true;
      setStatus("Preparing…");

      const conf = await loadConfig();
      let torrent;
      try {
        torrent = c.seed(file, { announce: conf.trackers || [] }, (t) => {
          setStatus(`Seeding "${t.name}" — keep this tab open to serve peers.`);
          magnetOut.value = t.magnetURI;
          magnetRow.style.display = "block";

          t.on("wire", () => setStatus(`Seeding — peers: ${t.numPeers}`));
          t.on("trackerAnnounce", (a) => log("Tracker announce: " + (a?.announce || a)));
          t.on("trackerWarning", (e) => log("Tracker warning: " + (e?.message || e)));
          t.on("trackerError", (e) => log("Tracker error: " + (e?.message || e)));
          t.on("noPeers", (type) => log("No peers: " + type));
          seedBtn.disabled = false;
        });
      } catch (e) {
        setStatus("Seed failed: " + (e?.message || e));
        seedBtn.disabled = false;
        return;
      }
      torrent.on("error", (e) => {
        setStatus("Torrent error: " + (e?.message || e));
        seedBtn.disabled = false;
      });
    }

    // Listeners
    playBtn.addEventListener('click', async () => {
      const uri = magnetEl.value.trim();
      if (!uri.startsWith("magnet:")) {
        alert("Please paste a valid magnet URI.");
        return;
      }
      const c = await ensureClient();
      playMagnet(c, uri).catch(e => log("Fatal: " + e.message));
    });

    seedBtn.addEventListener("click", async () => {
      const f = fileInput.files?.[0];
      if (!f) { setStatus("Choose an audio file first."); return; }
      const c = await ensureClient();
      seedLocalFile(c, f);
    });

    copyBtn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(magnetOut.value);
        copyBtn.textContent = "Copied";
        setTimeout(() => (copyBtn.textContent = "Copy magnet"), 1200);
      } catch {
        magnetOut.select();
        setStatus("Press ⌘/Ctrl+C to copy.");
      }
    });
  </script>
</body>
</html>
